/* 
 * POSTGRECR - MARC-HI CLIENT REGISTRY SEARCH FUNCTIONS FOR POSTGRESQL
 * VERSION: 2.0
 * AUTHOR: JUSTIN FYFE
 * DATE: JULY 12, 2012
 * FILES:
 *	POSTGRECR-DDL.SQL	- SQL CODE TO CREATE TABLES, INDECIES, VIEWS AND SEQUENCES
 *	POSTGRECR-SRCH.SQL	- SQL CODE TO CREATE SEARCH FUNCTIONS
 *	POSTGRESHR-FX.SQL	- SQL CODE TO CREATE SUPPORT PROCEDURES AND FUNCTIONS
 * DESCRIPTION:
 *	THIS FILE CLEANS AND THEN RE-CREATES THE POSTGRESQL CLIENT REGISTRY
 *	DATABASE SCHEMA INCLUDING TABLES, VIEWS, INDECIES AND SEQUENCES. 
 * LICENSE:
 * 	Licensed under the Apache License, Version 2.0 (the "License");
 * 	you may not use this file except in compliance with the License.
 * 	You may obtain a copy of the License at
 *
 *     		http://www.apache.org/licenses/LICENSE-2.0
 *
 * 	Unless required by applicable law or agreed to in writing, software
 * 	distributed under the License is distributed on an "AS IS" BASIS,
 * 	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * 	See the License for the specific language governing permissions and
 * 	limitations under the License.
 */

-- @FUNCTION 
-- FIND NAME COMPONENTS WITH A SIMILAR SOUNDING PARTS
CREATE OR REPLACE FUNCTION FIND_NAME_CMP_LIKE (
	NAME_VALUE_IN		IN VARCHAR(256),
	NAME_CMP_CLS_IN		IN DECIMAL(4),
	NAME_MIN_MATCH_IN	IN DECIMAL(1)
) RETURNS TABLE 
(
	NAME_SET_ID 	DECIMAL,
	SCORE 		INT
) 
AS
$$
BEGIN
	RETURN QUERY SELECT NAME_CMP_TBL.NAME_SET_ID, DIFFERENCE(NAME_VALUE_IN, NAME_CMP_VALUE) FROM NAME_CMP_TBL 
		WHERE DIFFERENCE(NAME_VALUE_IN, NAME_CMP_VALUE) >= NAME_MIN_MATCH_IN AND
			NAME_CMP_CLS = NAME_CMP_CLS_IN;
END;
$$ LANGUAGE plpgsql;

-- @FUNCTION
-- FIND NAME SETS
--
-- SOME PARAMETERS
--
--	NAME_MATCH_IN : THE DESIRED MATCHING STRENGTH (0 - 5)
--				5 	= USE EXACT STRING MATCHING
--				4 	= USE 100% SOUNDEX MATCHING
--				<3 	= USE < 75% SOUNDEX MATCHING
--
--	USE_VARIANTS_IN	: TRUE IF NAME VARIANTS SHOULD BE USED
--		WHEN NAME_MATCH_IN =
--				6	= NAME VARIANTS MUST BE EXACT MATCHES
--				5	= PATTERN MATCH USING ~~*
--				4	= NAME VARIANTS USE 100% SOUNDEX MATCHES
CREATE OR REPLACE FUNCTION FIND_PSN_BY_NAME_SET(
	NAME_CMP_VAL_IN	IN VARCHAR[],
	NAME_CMP_CLS_IN IN DECIMAL[],
	NAME_MATCH_IN	IN DECIMAL,
	USE_VARIANTS_IN	IN BOOLEAN,
	NAME_SET_USE_IN	IN DECIMAL(20)
) RETURNS TABLE (PSN_ID DECIMAL(20,0)) AS
$$
DECLARE
	CNCMP			DECIMAL;
	TMP_NAME_RET_TBL	DECIMAL[];
	TMP_NAME_RES_TBL	DECIMAL[];
	T_SOUNDEX		CHAR(4);
BEGIN


	T_SOUNDEX := SOUNDEX(NAME_CMP_VAL_IN[1]);
	-- FILTER THE FIRST SET
	TMP_NAME_RET_TBL := ARRAY(SELECT A.NAME_SET_ID FROM NAME_CMP_TBL A INNER JOIN NAME_CDTBL ON (A.NAME_CMP_VALUE = NAME_CDTBL.NAME_ID)
		WHERE 
			(
			(NAME_MATCH_IN = 6 AND NAME_VALUE ~* NAME_CMP_VAL_IN[1]) -- EXACT MATCH
				OR
			(NAME_MATCH_IN = 5 AND NAME_VALUE ~~* NAME_CMP_VAL_IN[1]) -- PATTERN MATCH
				OR
				  -- MATCH ON SOUNDEX
			(NAME_MATCH_IN = 4 AND (NAME_SOUNDEX = T_SOUNDEX OR NAME_VALUE ~~* NAME_CMP_VAL_IN[1])) 
				OR
				  -- FUZZY SOUNDEX MATCH
			(NAME_MATCH_IN < 4 AND DIFFERENCE(NAME_CDTBL.NAME_VALUE, NAME_CMP_VAL_IN[1]) >= NAME_MATCH_IN)
				OR
				  -- EXACT MATCH ON VARIANT
			(USE_VARIANTS_IN = TRUE AND NAME_MATCH_IN = 6 AND NAME_CMP_CLS_IN[1] = 1 AND UPPER(NAME_VALUE) IN (SELECT B.SYN_NAME FROM NAME_CMP_SYN_CDTBL B WHERE B.PRI_NAME ~* NAME_CMP_VAL_IN[1]))
				  -- PATTERN SOUNDEX
				OR
			(USE_VARIANTS_IN = TRUE AND NAME_MATCH_IN = 5 AND NAME_CMP_CLS_IN[1] = 1 AND UPPER(NAME_VALUE) IN (SELECT B.SYN_NAME FROM NAME_CMP_SYN_CDTBL B WHERE B.PRI_NAME ~~* NAME_CMP_VAL_IN[1]))
				OR
				  -- FUZZY SOUNDEX MATCH ON VARIANT
			(USE_VARIANTS_IN = TRUE AND NAME_MATCH_IN < 4 AND NAME_CMP_CLS_IN[1] = 1 AND UPPER(NAME_VALUE) IN (SELECT B.SYN_NAME FROM NAME_CMP_SYN_CDTBL B WHERE B.PRI_SOUNDEX = T_SOUNDEX AND STRENGTH >= NAME_MATCH_IN))

			) 
		AND -- SOUNDS LIKE PORTION
			NAME_CMP_CLS = NAME_CMP_CLS_IN[1]);

	-- SUBSEQUENT
	IF(ARRAY_LOWER(NAME_CMP_VAL_IN, 1) < ARRAY_UPPER(NAME_CMP_VAL_IN, 1)) THEN
		FOR CNCMP IN ARRAY_LOWER(NAME_CMP_VAL_IN, 1) + 1 .. ARRAY_UPPER(NAME_CMP_VAL_IN, 1) LOOP
			T_SOUNDEX := SOUNDEX(NAME_CMP_VAL_IN[CNCMP]);
			TMP_NAME_RET_TBL := ARRAY(
				SELECT A.NAME_SET_ID FROM NAME_CMP_TBL A INNER JOIN NAME_CDTBL ON (A.NAME_CMP_VALUE = NAME_CDTBL.NAME_ID)
				WHERE 
					(
					(NAME_MATCH_IN = 6 AND NAME_VALUE ~* NAME_CMP_VAL_IN[CNCMP]) 
						OR
					(NAME_MATCH_IN = 5 AND NAME_VALUE ~~* NAME_CMP_VAL_IN[CNCMP])
						OR
					(NAME_MATCH_IN = 4 AND (NAME_SOUNDEX = T_SOUNDEX OR NAME_VALUE ~~* NAME_CMP_VAL_IN[CNCMP])) 
						OR
					(NAME_MATCH_IN < 4 AND DIFFERENCE(NAME_CDTBL.NAME_VALUE, NAME_CMP_VAL_IN[CNCMP]) >= NAME_MATCH_IN)
						OR
					(USE_VARIANTS_IN = TRUE AND NAME_MATCH_IN = 6 AND NAME_CMP_CLS_IN[CNCMP] = 1 AND UPPER(NAME_VALUE) IN (SELECT B.SYN_NAME FROM NAME_CMP_SYN_CDTBL B WHERE B.PRI_NAME ~* NAME_CMP_VAL_IN[CNCMP]))
						OR
					(USE_VARIANTS_IN = TRUE AND NAME_MATCH_IN >= 4 AND NAME_CMP_CLS_IN[CNCMP] = 1 AND UPPER(NAME_VALUE) IN (SELECT B.SYN_NAME FROM NAME_CMP_SYN_CDTBL B WHERE B.PRI_NAME ~~* NAME_CMP_VAL_IN[CNCMP]))
						OR
					(USE_VARIANTS_IN = TRUE AND NAME_MATCH_IN < 4 AND NAME_CMP_CLS_IN[CNCMP] = 1 AND UPPER(NAME_VALUE) IN (SELECT B.SYN_NAME FROM NAME_CMP_SYN_CDTBL B WHERE B.PRI_SOUNDEX = T_SOUNDEX AND STRENGTH >= 3))
					)
				AND -- SOUNDS LIKE PORTION
					NAME_CMP_CLS = NAME_CMP_CLS_IN[CNCMP]
				AND 
					A.NAME_SET_ID = ANY (TMP_NAME_RET_TBL));

		END LOOP;
	END IF;
	
	RETURN QUERY SELECT PSN_NAME_SET_TBL.PSN_ID FROM PSN_NAME_SET_TBL WHERE 
		PSN_NAME_SET_TBL.NAME_SET_ID = ANY (TMP_NAME_RET_TBL) 
			AND
		(NAME_SET_USE_IN IS NOT NULL AND NAME_SET_USE = NAME_SET_USE_IN OR NAME_SET_USE_IN IS NULL) 
			AND
		OBSLT_VRSN_ID IS NULL;
END;
$$ LANGUAGE plpgsql;

-- @FUNCTION
-- FIND A PERSON IDENTIFIER BY THE BIRTHTIME
CREATE OR REPLACE FUNCTION FIND_PSN_BY_BRTH_TS(
	TS_VALUE_IN	IN TIMESTAMPTZ,
	TS_PRECISION_IN	IN CHAR(1)
) RETURNS TABLE (PSN_ID DECIMAL(20,0)) AS
$$
DECLARE
	TS_PRECISION_IVL	INTERVAL;
	TS_VALUE_DATE		DATE; -- FOR DATE QUERIES
BEGIN
	
	-- DETERMINE THE IVL
	IF TS_PRECISION_IN = 'Y' THEN
		TS_PRECISION_IVL = '1 YEAR'::INTERVAL;
		TS_VALUE_DATE = CAST(TS_VALUE_IN AS DATE);
	ELSIF TS_PRECISION_IN = 'M' THEN
		TS_PRECISION_IVL = '1 MONTH'::INTERVAL;
		TS_VALUE_DATE = CAST(TS_VALUE_IN AS DATE);
	ELSIF TS_PRECISION_IN = 'D' THEN
		TS_PRECISION_IVL = '1 DAY'::INTERVAL;
		TS_VALUE_DATE = CAST(TS_VALUE_IN AS DATE);
	ELSIF TS_PRECISION_IN = 'H' THEN
		TS_PRECISION_IVL = '1 HOUR'::INTERVAL;
	ELSIF TS_PRECISION_IN = 'm' THEN
		TS_PRECISION_IVL = '1 MINUTE'::INTERVAL;
	ELSIF TS_PRECISION_IN = 'S' THEN
		TS_PRECISION_IVL = '1 SECOND'::INTERVAL;
	ELSIF TS_PRECISION_IN = 'F' THEN
		TS_PRECISION_IVL = '1 DAY'::INTERVAL;
	END IF;

	-- EXECUTE QUERY
	RETURN QUERY SELECT PSN_VRSN_TBL.PSN_ID FROM 
		PSN_VRSN_TBL INNER JOIN TS_TBL ON (PSN_VRSN_TBL.BRTH_TS = TS_TBL.TS_ID) 
	WHERE 
		TS_VALUE BETWEEN TS_VALUE_IN AND TS_VALUE_IN + TS_PRECISION_IVL::INTERVAL - '1 MILLISECOND'::INTERVAL 
			AND 	
		PSN_VRSN_TBL.OBSLT_UTC IS NULL;
END
$$ LANGUAGE plpgsql;

-- @FUNCTION
-- LOOKUP CANDIDATES BY GENDER CODE
CREATE OR REPLACE FUNCTION FIND_PSN_BY_GNDR_CS (
	GNDR_CS_IN	IN VARCHAR(2)
) RETURNS TABLE(PSN_ID DECIMAL(20,0)) AS 
$$
BEGIN
	RETURN QUERY SELECT PSN_VRSN_TBL.PSN_ID FROM PSN_VRSN_TBL WHERE GNDR_CS = GNDR_CS_IN AND OBSLT_UTC IS NULL;
END;
$$ LANGUAGE plpgsql;

-- @FUNCTION
-- LOOKUP CANDIDATES BY TELECOM
CREATE OR REPLACE FUNCTION FIND_PSN_BY_TEL(
	TEL_VALUE_IN	IN VARCHAR(255),
	TEL_USE_IN	IN VARCHAR(32)
) RETURNS TABLE (PSN_ID DECIMAL(20,0)) AS 
$$
BEGIN
	RETURN QUERY SELECT PSN_TEL_TBL.PSN_ID FROM PSN_TEL_TBL WHERE OBSLT_VRSN_ID IS NULL AND TEL_VALUE = TEL_VALUE_IN AND
		(TEL_USE_IN IS NOT NULL AND TEL_USE = TEL_USE_IN OR TEL_USE_IN IS NULL);
END
$$ LANGUAGE plpgsql;


-- @FUNCTION
-- LOOKUP CANDIDATES BY TELECOM
CREATE OR REPLACE FUNCTION FIND_PSN_BY_TEL_LIKE(
	TEL_VALUE_IN	IN VARCHAR(255),
	TEL_USE_IN	IN VARCHAR(32)
) RETURNS TABLE (PSN_ID DECIMAL(20,0)) AS 
$$
BEGIN
	RETURN QUERY SELECT PSN_TEL_TBL.PSN_ID FROM PSN_TEL_TBL WHERE OBSLT_VRSN_ID IS NULL AND TEL_VALUE LIKE TEL_VALUE_IN AND
		(TEL_USE_IN IS NOT NULL AND TEL_USE = TEL_USE_IN OR TEL_USE_IN IS NULL);
END
$$ LANGUAGE plpgsql;

-- @FUNCTION
-- FIND ADDR SETS
--
CREATE OR REPLACE FUNCTION FIND_PSN_BY_ADDR_SET(
	ADDR_CMP_VAL_IN	IN VARCHAR[],
	ADDR_CMP_CLS_IN IN DECIMAL[],
	ADDR_SET_USE_IN	IN DECIMAL(20)
) RETURNS TABLE (PSN_ID DECIMAL(20,0)) AS
$$
DECLARE
	CNCMP			DECIMAL;
	TMP_ADDR_RET_TBL	DECIMAL[];
	TMP_ADDR_RES_TBL	DECIMAL[];
BEGIN


	-- FILTER THE FIRST SET
	TMP_ADDR_RET_TBL := ARRAY(SELECT A.ADDR_SET_ID FROM ADDR_CMP_TBL A INNER JOIN ADDR_CDTBL ON (A.ADDR_CMP_VALUE = ADDR_CDTBL.ADDR_ID)
		WHERE UPPER(ADDR_VALUE) = UPPER(ADDR_CMP_VAL_IN[1])
		AND 
			ADDR_CMP_CLS = ADDR_CMP_CLS_IN[1]);

	-- SUBSEQUENT
	IF(ARRAY_LOWER(ADDR_CMP_VAL_IN, 1) < ARRAY_UPPER(ADDR_CMP_VAL_IN, 1)) THEN
		FOR CNCMP IN ARRAY_LOWER(ADDR_CMP_VAL_IN, 1) + 1 .. ARRAY_UPPER(ADDR_CMP_VAL_IN, 1) LOOP
			TMP_ADDR_RET_TBL := ARRAY(
				SELECT A.ADDR_SET_ID FROM ADDR_CMP_TBL A INNER JOIN ADDR_CDTBL ON (A.ADDR_CMP_VALUE = ADDR_CDTBL.ADDR_ID)
				WHERE UPPER(ADDR_VALUE) = UPPER(ADDR_CMP_VAL_IN[CNCMP]) 
				AND 
					ADDR_CMP_CLS = ADDR_CMP_CLS_IN[CNCMP]
				AND 
					A.ADDR_SET_ID = ANY (TMP_ADDR_RET_TBL));

		END LOOP;
	END IF;
	
	RETURN QUERY SELECT PSN_ADDR_SET_TBL.PSN_ID FROM PSN_ADDR_SET_TBL WHERE 
		PSN_ADDR_SET_TBL.ADDR_SET_ID = ANY (TMP_ADDR_RET_TBL) 
			AND
		(ADDR_SET_USE_IN IS NOT NULL AND ADDR_SET_USE = ADDR_SET_USE_IN OR ADDR_SET_USE_IN IS NULL) 
			AND
		OBSLT_VRSN_ID IS NULL;
END;
$$ LANGUAGE plpgsql;

-- FIND PERSON BY EXTERNAL IDENTIFIER DOMAIN
CREATE OR REPLACE FUNCTION FIND_PSN_EXTERN
(
	ID_DOMAIN_IN	IN VARCHAR
) RETURNS TABLE (PSN_ID DECIMAL(20,0)) AS
$$
BEGIN
	RETURN QUERY SELECT PSN_ALT_ID_TBL.PSN_ID FROM PSN_ALT_ID_TBL WHERE ID_DOMAIN = ID_DOMAIN_IN AND 
		IS_HCN = TRUE AND IS_PRVT = FALSE AND
		OBSLT_VRSN_ID IS NULL;
END;
$$ LANGUAGE PLPGSQL;

